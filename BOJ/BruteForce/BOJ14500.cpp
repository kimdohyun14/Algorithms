#include <iostream>
#define SIZE 500
using namespace std;

//5개의 블럭을 회전이나 대칭을 이용해서 미리 다 구해놓는다.
int block[19][3][2] = {
	{{0,1},{0,2},{0,3}},
	{{1,0},{2,0},{3,0}},

	{{0,1},{1,0},{1,1}},

	{{1,0},{2,0},{2,1}},
	{{0,1},{0,2},{1,0}},
	{{0,1},{1,1},{2,1}},
	{{0,1},{0,2},{-1,2}},
	{{0,1},{1,0},{2,0}},
	{{1,0},{1,1},{1,2}},
	{{0,1},{-1,1},{-2,1}},
	{{0,1},{0,2},{1,2}},

	{{1,0},{1,1},{2,1}},
	{{0,1},{-1,1},{-1,2}},
	{{1,0},{1,-1},{2,-1}},
	{{0,1},{1,1},{1,2}},

	{{0,1},{0,2},{1,1}},
	{{1,0},{2,0},{1,1}},
	{{0,1},{0,2},{-1,1}},
	{{1,0},{2,0},{1,-1}}
};

int N, M;
int board[SIZE][SIZE];
int ans;

//N*M인 종이 위에 테트로미노를 하나 올렸을 때, 그 값의 합이 최대인 경우를 찾는다.

int main() {
	cin >> N >> M;
	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < M; ++j) {
			cin >> board[i][j];
		}
	}

	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < M; ++j) {
			//19개의 블럭을 사용해본다. 
			for (int k = 0; k < 19; ++k) {
				int sum = board[i][j]; //시작위치 더하기
				bool isPossible = true; //판 위에 블럭을 들 수 있는지?
				//각 시작위치를 기준으로 블럭들을 둘 수 있는지 체크
				for (int l = 0; l < 3; ++l) {
					int x = i + block[k][l][0];
					int y = j + block[k][l][1];
					if (x >= 0 && x < N && y >= 0 && y < M) {
						sum += board[x][y];
					}
					else {
						isPossible = false;
						break;
					}
				}
				//하나라도 블럭이 바운더리 이외의 지역에 두지 않았다면,
				//동시에 구한 값보다 더 큰 값이 있다면 갱신해준다.
				if (isPossible && ans < sum) {
					ans = sum;
				}
			}
		}
	}
	cout << ans;
	return 0;
}