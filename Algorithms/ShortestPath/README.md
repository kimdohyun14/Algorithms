## 최단 경로 알고리즘
가장 짧은 경로를 찾는 알고리즘이며 아래와 같은 유형들이 있다.    
* `한 지점에서 다른 모든 지점까지의 최단 경로를 구해야 하는 경우` -> `다익스트라 알고리즘`    
* `모든 지점에서 다른 모든 지점까지의 최단 경로를 구해야 하는 경우` -> `플로이드 워셜 알고리즘`
* `음의 간선을 포함한 최단 경로를 구해야 하는 경우` -> `벨만 포드 알고리즘`

### 다익스트라 알고리즘 (Dijkstra Algorithm)
`한 지점에서 다른 모든 지점까지의 최단 경로`를 구해야할 때 사용하는 알고리즘이다.    
음의 간선이 존재하지 않는 전제조건에서 최단 경로를 구해준다.    
동작 방식은 다음과 같다.
1. 최단 거리 테이블을 초기화한다. (보통은 무한으로 초기화, 간혹 -1인 경우도 있다.) 문제마다 다르지만 무한은 보통 `1e9`
2. 출발 노드를 설정한다. (출발 노드로부터 다른 모든 노드까지의 최단 경로를 구하는 알고리즘)
3. 방문하지 않는 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다. (우선순위 큐를 이용)
4. 해당 노드를 거쳐 다른 노드로 가는 비용이 더 짧다면 최단 거리 테이블을 갱신한다.

다익스트라 알고리즘의 핵심은 2가지이다.    
1. 한 번 선택된 노드는 `최단 거리`가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다는 점이다.    
그러한 부분들은 계산하지 않고 무시할 수 있도록 아래와 같은 코드를 작성하면 쉽게 구현이 가능하다.    
visited 배열을 대신한다는 장점도 있다.    
```cpp
if(d[now] < dist) continue;
```

2. 방문하지 않는 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정은 우선순위 큐를 이용하자.    
`우선순위 큐`를 이용하여 `O(logV)`로 해당 노드를 찾아주면, 훨씬 빠르게 동작할 수 있다.
이를 구현하지 않고 직접 순차탐색으로 찾는다면 `O(V)`가 된다.    
`C++`에서는 `priority_queue`를 이용해서 우선순위 큐를 쉽게 사용이 가능하다. 이 때, 다익스트라 알고리즘은 최소 힙을 기반으로 동작하므로
(왜냐하면 최단 거리가 가장 짧은 노드를 선택해야 하므로), C++의 Default는 `MAX-Heap`기반이므로 `-`를 붙여주게 되면 간단하게 `MIN-Heap`을 구성할 수 있다.
아래의 예시처럼 사용하면 쉽게 우선순위 큐를 구현할 수 있다.    
```cpp
priority_queue<int> pq; // 기본적인 형태는 Max-heap 구조
pq.push({-cost, node}); // 튜플 형태를 {거리, 노드}로 넣을 때, 거리(비용)부분을 -를 곱해서 넣어주게 되면, Min-heap으로 동작하게 된다.
int dist = -pq.top().first; // 이처럼 빼낼 때도 -를 곱하면, Min-heap으로 동작하게 된다.
int now = pq.top().second; 
```

다익스트라의 전체 시간 복잡도는 `노드의 수가 V`, `간선의 수가 E`라고 했을 때, `O(ElogV)`이다.    
방문하지 않는 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정은 우선순위 큐에 의해서 `O(logV)`로 뽑을 수 있고,
해당 노드에서 인접한 노드들을 확인하는 과정은 해당 노드에서 뻗어나가는 간선이므로 `O(E)`로 확인할 수 있다. 그렇기 때문에 `O(ElogV)`가 나오게 된다.

### 플로이드 워셜 알고리즘 (Floyd Warshall Algorithm)
`모든 지점에서 다른 모든 지점까지의 최단 경로`를 모두 구해야 하는 경우 사용하는 알고리즘이다.    
물론, 다익스트라를 모든 정점에서 다 돌리면 그 결과는 플로이드 워셜 알고리즘과 같지만, 효율성과 정확성 면에서는 플로이드 워셜 알고리즘을 한 번 짜는 것이 더 빠르게 동작한다.    
`다익스트라 알고리즘`은 단계마다 `최단 거리를 가지는 노드를 하나씩 반복적으로 선택`하여, 해당 노드를 거쳐 가는 경로를 확인하여 최단 거리 테이블을 갱신했다면, 
`플로이드 워셜 알고리즘`은 단계마다 `거쳐 가는 노드`를 기준으로 알고리즘을 수행한다.    
다익스트라와 다르게 매번 방문하지 않는 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다.    
플로이드 워셜의 전체 시간 복잡도는 해당 노드에서 그 노드로 가는 비용을 계산할 때, 거쳐가는 비용도 고려하기 때문에 `O(V^3)`가 된다.    
```cpp
for (int k = 1; k <= n; k++) { // 거쳐가는 노드
	for (int a = 1; a <= n; a++) { // 출발 노드
		for (int b = 1; b <= n; b++) { // 도착 노드
			graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b]);
		}
	}
}
```
`a -> b`로 가는 최단 경로는 `a -> b`로 가는 비용과 `a -> k -> b`로 가는 비용 중 `더 작은 비용`으로 갱신된다.    
다익스트라는 결과 배열이 `1차원 배열`이였다면, 플로이드는 `2차원 배열`에 최단 거리 정보를 저장한다.    
다익스트라와 마찬가지로 연결되지 않는 간선은 `무한`이라고 가정해놓고 시작한다.    
